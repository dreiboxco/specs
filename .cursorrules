# Cursor Rules - Spec Driven Development

## Linguagem e comunicação
- Responder sempre em português (pt-BR).

## Fonte da verdade e fluxo SDD
- Especificar antes de codificar. Só gerar/alterar código a partir de specs em `specs/` validadas.
- Não implementar feature sem `*.spec.md` completa e checada pelo `specs/checklist.md`.
- Antes de iniciar implementação, passar a spec pelo checklist; se houver item reprovado, solicitar atualização da spec ao usuário e oferecer-se para fazê-la, pedindo apenas revisão.

## Fluxo obrigatório de consulta de specs
- **SEMPRE**, antes de implementar qualquer funcionalidade, feature ou mudança solicitada pelo usuário:
  1. Consultar as specs existentes em `specs/` para verificar se a funcionalidade já está especificada.
  2. Se a funcionalidade **estiver especificada** em uma spec válida:
     - Verificar se a spec está completa e passa pelo checklist.
     - Se estiver completa, **implementar diretamente** conforme a spec.
     - Se houver pendências no checklist, solicitar atualização da spec ao usuário antes de implementar.
  3. Se a funcionalidade **NÃO estiver especificada**:
     - Identificar qual spec existente deve ser ajustada (se aplicável) OU se é necessário criar uma nova spec.
     - Se ficar em dúvida sobre qual spec ajustar ou se deve criar nova, **PERGUNTAR ao usuário** qual spec ajustar ou se deve criar nova.
     - Propor a criação/ajuste da spec e **AGUARDAR CONFIRMAÇÃO EXPLÍCITA do usuário** antes de implementar.
  4. **NUNCA implementar código sem ter uma spec válida e confirmada pelo usuário** (exceto para correções de bugs críticos ou ajustes técnicos menores que não alterem comportamento funcional).
  5. Se o usuário solicitar algo que requer mudança em spec existente, mostrar o que será alterado na spec e aguardar aprovação antes de modificar tanto a spec quanto o código.

## Estrutura e diretórios
- Respeitar a estrutura definida em `specs/00-architecture.spec.md`. Não criar novas pastas fora do acordado.
- `specs/` não recebe código executável.

## Especificações: Abstração de Detalhes de Implementação
- **NUNCA incluir detalhes de implementação técnica nas specs de funcionalidades** (arquivos `01-*.spec.md`, `02-*.spec.md`, etc.).
- **Detalhes de stack técnica** (linguagem, ferramentas de build, comandos de build específicos) devem estar **APENAS** em `00-stack.spec.md`.
- **O que NÃO deve aparecer em specs de funcionalidades:**
  - Nomes de ferramentas de build específicas (ex.: `goreleaser`, `go build`, etc.)
  - Comandos de build específicos (ex.: `go build`, `make build`, etc.)
  - Nomes de linguagens/runtimes específicos em contexto de implementação (ex.: "binário gerado via go build", "compilado com Go", etc.)
  - Detalhes de ferramentas de desenvolvimento (ex.: "executar golangci-lint", "rodar gofmt", etc.)
  - Bibliotecas específicas de implementação (ex.: "usar biblioteca X do Go", etc.)
- **O que DEVE aparecer em specs de funcionalidades:**
  - Comportamento funcional (o que o comando faz, não como é construído)
  - Contratos e interfaces (inputs, outputs, formatos)
  - Requisitos não funcionais (latência, compatibilidade de plataforma, etc.) - mas sem mencionar ferramentas específicas
  - Referências genéricas quando necessário (ex.: "binário único", "compilado estaticamente", "sem dependências externas", "artefato portável")
- **Exceções:**
  - Specs de stack técnica (`00-stack.spec.md`) podem e devem ter detalhes técnicos
  - Specs de CI/CD podem mencionar ferramentas de CI/CD, mas devem referenciar `00-stack.spec.md` para detalhes de build
- **Quando em dúvida:** Se precisar mencionar algo técnico, referenciar `00-stack.spec.md` ao invés de detalhar na spec de funcionalidade.

## Guardrails de dependências
- Evitar adicionar dependências novas. Se inevitável, justificar na spec ou em ADR antes de incluir.
- **Antes de adicionar dependência:**
  - Verificar se funcionalidade pode ser implementada sem dependência externa
  - Avaliar: tamanho, manutenção, licença, compatibilidade
  - Criar ADR justificando a dependência
  - Verificar vulnerabilidades conhecidas
- **Dependências permitidas:**
  - Bibliotecas padrão da linguagem (preferir)
  - Bibliotecas amplamente utilizadas e mantidas
  - Evitar dependências que adicionam > 1MB ao binário final
- **Versionamento:**
  - Fixar versões major (ex: `v1.2.3` não `^v1.2.3`)
  - Atualizar dependências regularmente (security patches)
  - Documentar atualizações em changelog

## UX de CLI
- Mensagens curtas e acionáveis.
- Help sempre disponível (`--help`).
- Códigos de saída padronizados: 0 ok; 1 erro genérico; 2 input inválido; 3 rede; 4 auth; 5 update.
- stdout reservado ao output do comando; stderr para erros/logs.

## Segurança
- Nunca logar ou imprimir segredos/tokens.
- Não escrever/alterar arquivos de configuração sem confirmação explícita do usuário.
- Armazenamento seguro para tokens/confs conforme especificação (usar XDG-compliant paths).

## Observabilidade e NFRs
- `--debug` opcional para logs verbosos quando previsto na spec.
- Seguir metas de latência/portabilidade da spec; preferir binário único se a stack permitir.
- **Níveis de log:**
  - ERROR: Erros que impedem operação
  - WARN: Situações anômalas mas recuperáveis
  - INFO: Eventos importantes do fluxo (opcional, usar com parcimônia)
  - DEBUG: Detalhes para troubleshooting (apenas com `--debug`)
- **Estrutura de logs:**
  - Formato estruturado quando possível (JSON em modo debug)
  - Incluir contexto: comando, operação, caminhos (sem dados sensíveis)
  - Correlação: request-id ou operation-id quando aplicável
- **Métricas:**
  - Documentar métricas importantes na spec
  - Considerar exposição de métricas (Prometheus, etc.) para projetos grandes

## Instalação e auto-update
- Seguir estratégia descrita na arquitetura (ex.: `curl | sh`, checksum/assinatura, rollback seguro).
- Não mudar instalador/update sem spec/ADR.

## Testes e critérios de aceite
- Gerar/rodar testes previstos em cada spec (unidade, integração, e2e/instalador).
- Validar critérios de aceite antes de concluir a tarefa.
- **Estratégia de testes:**
  - Testes unitários: isolar dependências com mocks
  - Testes de integração: usar testcontainers ou fixtures quando necessário
  - Testes E2E: apenas para fluxos críticos
  - Testes de performance: para operações que têm requisitos de latência
- **Organização:**
  - Testes no mesmo pacote (`*_test.go`)
  - Testes de integração: usar build tags (`//go:build integration`)
  - Fixtures: organizar em `testdata/` por funcionalidade
  - Mocks: gerar quando possível, manter atualizados
- **Cobertura:**
  - Mínimo 80% de cobertura para código novo
  - Manter cobertura existente ao refatorar
  - Documentar casos de teste complexos

## Migração / rollback
- Qualquer mudança de estado/local/config requer plano de migração e rollback na spec.

## Compatibilidade
- Manter suporte a SO/CPU definidos (macOS/Linux; Windows só se explicitado).
- Evitar paths hardcoded; respeitar XDG quando aplicável.

## Documentação (README)
- **Toda documentação geral deve ser centralizada e mantida APENAS em `README.md` na raiz do projeto.**
- **NUNCA criar arquivos de documentação separados** (ex.: `INSTALL.md`, `DEVELOPMENT.md`, `CONTRIBUTING.md`, `docs/*.md`, etc.) a menos que seja explicitamente solicitado pelo usuário.
- **Estruturar o `README.md` em seções claras e organizadas:**
  - Visão Geral
  - Instalação (com todas as opções, variáveis de ambiente, troubleshooting)
  - Uso (comandos básicos, exemplos)
  - Comandos Disponíveis (lista completa)
  - Atualização (como atualizar o CLI)
  - Desenvolvimento (build, testes, formatação)
  - CI/CD e Releases (se aplicável)
  - Compatibilidade (plataformas suportadas)
  - Especificações (referências às specs)
  - Estrutura do Projeto
  - Contribuindo (se aplicável)
- **Ao finalizar qualquer entrega/geração, atualizar `README.md` refletindo o estado atual:**
  - Adicionar novos comandos na seção "Comandos Disponíveis"
  - Atualizar instruções de instalação se houver mudanças
  - Documentar novas funcionalidades na seção apropriada
  - Atualizar exemplos de uso
- **Exceções:**
  - Specs em `specs/` (são documentação técnica de especificação, não documentação de usuário)
  - Arquivos de configuração com comentários (ex.: `.goreleaser.yml`, `.github/workflows/*.yml`)
  - Comentários inline no código
- **Se houver documentação dispersa em outros arquivos, consolidar no `README.md` e remover os arquivos separados.**

## Versionamento e Build

- **Incremento automático de versão:**
  - Durante build de release, versão deve ser incrementada automaticamente no arquivo `VERSION`
  - Incremento padrão: PATCH (0.0.1 → 0.0.2)
  - Arquivo `VERSION` deve ser atualizado antes do build
  - Versão deve seguir formato semântico (MAJOR.MINOR.PATCH)

- **Criação de tags Git:**
  - Após incremento de versão, tag Git deve ser criada automaticamente
  - Formato da tag: `v{MAJOR}.{MINOR}.{PATCH}` (ex.: `v0.0.2`)
  - Tag deve ser criada localmente e enviada para repositório remoto
  - Mensagem da tag: "Release v{versão}"

- **Integração CI/CD:**
  - GitHub Actions deve ser acionado automaticamente quando tag é criada
  - Workflow deve executar build para todas as plataformas alvo
  - Workflow deve criar release no GitHub com artefatos e checksums SHA256

- **Comando de versão:**
  - Comando `specs version` deve exibir versão atual do CLI
  - Versão deve ser lida do arquivo `VERSION` ou injetada durante build
  - Detalhes completos em `specs/01-version-control.spec.md`

## Gitflow e Conventional Commits
- **O projeto utiliza Gitflow como estratégia de branching:**
  - `main`: branch de produção (código estável e testado)
  - `develop`: branch de desenvolvimento (integração contínua)
  - `feature/{numero}-{nome}`: branches para novas funcionalidades (ex.: `feature/02-init`)
  - `release/{versao}`: branches para preparação de releases (ex.: `release/1.0.0`)
  - `hotfix/{descricao}`: branches para correções urgentes em produção
- **Todas as mensagens de commit devem seguir o padrão Conventional Commits:**
  - Formato: `<tipo>(<escopo>): <descrição>`
  - Tipos permitidos:
    - `feat`: Nova funcionalidade (incrementa versão MINOR)
    - `fix`: Correção de bug (incrementa versão PATCH)
    - `docs`: Mudanças em documentação
    - `style`: Formatação, ponto e vírgula faltando, etc (não altera código)
    - `refactor`: Refatoração de código (não adiciona funcionalidade nem corrige bug)
    - `perf`: Melhoria de performance
    - `test`: Adição ou correção de testes
    - `chore`: Mudanças em build, dependências, ferramentas auxiliares
    - `ci`: Mudanças em CI/CD
    - `build`: Mudanças em sistema de build ou dependências externas
  - Escopo (opcional): área afetada (ex.: `init`, `validate`, `cli`)
  - Descrição: curta, em português, no imperativo (ex.: "adiciona validação de diretório")
  - Exemplos válidos:
    - `feat(init): adiciona comando init básico`
    - `fix(validate): corrige validação de arquivos vazios`
    - `docs: atualiza README com instruções de instalação`
    - `refactor(cli): simplifica estrutura de comandos`
- **Ao gerar commits automaticamente:**
  - Sempre usar Conventional Commits
  - Escolher o tipo apropriado baseado nas mudanças
  - Incluir escopo quando relevante
  - Descrição em português, imperativo, clara e concisa
  - Não incluir quebra de linha no título (máximo 72 caracteres)
- **Relação com branches:**
  - Branches `feature/*`: preferir `feat:` para novas funcionalidades
  - Branches `hotfix/*`: usar `fix:` para correções
  - Branches `release/*`: podem ter `feat:`, `fix:`, `chore:` conforme necessário
  - Branch `develop`: pode ter qualquer tipo conforme o merge

## Commits automatizados
- Quando o usuário digitar "commit" no Cursor, gerar commit seguindo **Conventional Commits** com mensagem explicativa em português do Brasil do que foi feito e aplicar na branch atual correta. Confirmar que não há pendências de checklist/spec antes de commitar.

## Commits de specs
- **NUNCA commitar automaticamente arquivos em `specs/`** (arquivos `*.spec.md`) **após criar ou modificar uma spec**.
- Ao criar ou modificar uma spec, **NÃO commitar automaticamente**. Apenas informar o usuário sobre as mudanças.
- Se o usuário solicitar commit explicitamente (ex.: "commit"), **incluir as specs no commit normalmente** junto com o código.
- Não é necessário perguntar separadamente sobre specs quando o usuário pedir commit - incluir tudo no mesmo commit.
- A regra é apenas para **não commitar automaticamente após criar/modificar specs** sem o usuário pedir.

## Gerenciamento de branches para implementação de specs
- **Ao iniciar implementação de uma nova spec:**
  - Verificar qual spec será implementada (ex.: `04-specs-installer.spec.md`).
  - Extrair número e nome da spec (ex.: `04-specs-installer`).
  - Criar branch `feature/04-specs-installer` (formato: `feature/{numero}-{nome-sem-extensao}`).
  - Fazer checkout para a nova branch antes de começar a implementação.
  - Informar ao usuário sobre a criação da branch.
- **Ao mudar de spec (implementar outra spec diferente):**
  - Verificar se há uma branch de feature ativa.
  - **PERGUNTAR ao usuário** se deseja fazer merge da branch atual para `development` antes de mudar.
  - Se o usuário confirmar merge:
    - Fazer merge da branch atual para `development`.
    - Fazer checkout para `development`.
    - Criar nova branch para a próxima spec.
  - Se o usuário não quiser fazer merge, manter branch atual e criar nova branch para a próxima spec.
  - Sempre informar ao usuário sobre a mudança de branch e o estado atual.
- **Nomenclatura de branches:**
  - Formato: `feature/{numero}-{nome-sem-extensao}`
  - Exemplos: `feature/01-specs-version`, `feature/02-specs-update`, `feature/04-specs-installer`
  - Remover extensão `.spec.md` e hífens extras do nome da spec.

## Gerenciamento de Checklist nas Specs
- **Ao implementar uma funcionalidade especificada:**
  - Após concluir a implementação e validar que todos os critérios de aceite foram atendidos, **marcar automaticamente todos os itens do checklist** na spec correspondente.
  - Atualizar o checklist da spec mudando `- [ ]` para `- [x]` para cada item que foi implementado e validado.
  - Se algum item do checklist não se aplica à implementação (ex.: "Migração/rollback" em comandos que não alteram estado), marcar como `- [x]` com uma nota explicativa ou deixar marcado se já estava assim.
  - **Nunca marcar itens do checklist como concluídos antes de implementar e validar** a funcionalidade correspondente.
  - Se a implementação estiver parcial (ex.: apenas alguns requisitos foram implementados), marcar apenas os itens correspondentes aos requisitos implementados.
- **Formato do checklist:**
  - Todos os checklists devem usar o formato padronizado: `- [ ]` para pendente e `- [x]` para concluído.
  - O checklist deve estar localizado no final da spec, após a seção "Abertos / Fora de Escopo".
  - O checklist deve conter exatamente 6 itens conforme o template padrão.
- **Validação de status:**
  - O comando `specs list` verifica automaticamente se todos os itens do checklist estão marcados para determinar se a spec está "completa" ou "incompleta".
  - Uma spec só é considerada completa se: (1) possui todas as seções obrigatórias E (2) todos os itens do checklist estão marcados como `- [x]`.
- **Comandos úteis para validação:**
  - `specs validate [caminho]` - Valida uma ou todas as specs contra o checklist formal
  - `specs check [caminho]` - Verifica consistência estrutural (formato, numeração, links, referências)
  - `specs list` - Lista todas as specs com status (completa/incompleta)

## Refatoração e Manutenção de Código Legado
- **Antes de refatorar código existente:**
  - Verificar se há spec relacionada e se a refatoração altera comportamento
  - Se alterar comportamento funcional, criar/atualizar spec primeiro
  - Se for apenas melhoria técnica (performance, legibilidade), documentar em comentário ou ADR
- **Código legado sem spec:**
  - Ao encontrar código sem spec correspondente, criar spec retroativamente antes de modificar
  - Documentar comportamento atual na spec antes de refatorar
- **Refatoração incremental:**
  - Preferir refatorações pequenas e incrementais
  - Manter compatibilidade durante refatoração (não quebrar APIs existentes)
  - Testes devem passar antes e depois da refatoração
- **Complexidade e tamanho:**
  - Complexidade ciclomática: manter funções simples (< 15)
  - Tamanho de arquivos: preferir < 300 linhas, considerar divisão se > 500
  - Tamanho de funções: preferir < 50 linhas, considerar divisão se > 100

## Architecture Decision Records (ADRs)
- **Quando criar ADR:**
  - Decisões arquiteturais significativas que afetam múltiplos módulos
  - Escolha de bibliotecas/frameworks externos
  - Mudanças em padrões estabelecidos
  - Decisões que podem ser questionadas no futuro
- **Formato:**
  - Localização: `docs/adr/` ou `specs/adr/`
  - Numeração sequencial: `ADR-001-decisao.md`
  - Estrutura: Contexto, Decisão, Consequências, Alternativas consideradas
- **Integração com specs:**
  - ADRs podem referenciar specs e vice-versa
  - Decisões técnicas detalhadas devem estar em ADRs, não em specs de funcionalidade

## Code Review e Qualidade
- **Antes de solicitar review:**
  - Todos os testes passando localmente
  - Checklist da spec marcado (se aplicável)
  - Código formatado e sem warnings de linter
  - README atualizado se necessário
- **Padrões de qualidade:**
  - Complexidade ciclomática: manter funções simples (< 15)
  - Tamanho de arquivos: preferir < 300 linhas, considerar divisão se > 500
  - Cobertura de testes: mínimo 80% para código novo
  - Documentação: funções públicas devem ter comentários GoDoc
- **Revisão de código:**
  - Focar em: correção, clareza, testabilidade, manutenibilidade
  - Verificar se segue padrões arquiteturais definidos
  - Garantir que testes cobrem casos de borda

## Performance e Otimização
- **Otimização prematura:**
  - Não otimizar sem métricas que justifiquem
  - Medir antes e depois de otimizações
  - Documentar trade-offs em ADR se significativo
- **Quando otimizar:**
  - Performance abaixo das metas definidas na spec
  - Problemas identificados em produção
  - Refatoração que melhora legibilidade E performance
- **Profiling:**
  - Usar ferramentas de profiling antes de otimizar
  - Documentar resultados em comentários ou ADR

## Deprecação de Features
- **Processo de deprecação:**
  1. Atualizar spec marcando feature como deprecated
  2. Adicionar aviso no código e CLI (mensagem de deprecation)
  3. Documentar alternativa recomendada
  4. Manter compatibilidade por pelo menos 2 versões MAJOR
  5. Remover apenas em nova versão MAJOR
- **Comunicação:**
  - Changelog deve listar features deprecated
  - README deve documentar mudanças
  - Mensagens de deprecation devem ser claras e acionáveis

## Breaking Changes
- **Processo para breaking changes:**
  1. Criar spec documentando a mudança e justificativa
  2. Planejar migração e compatibilidade temporária
  3. Comunicar em changelog e release notes
  4. Incrementar versão MAJOR
  5. Fornecer guia de migração quando aplicável
- **Compatibilidade:**
  - Manter compatibilidade com versão anterior quando possível
  - Período de transição: suportar ambos os formatos temporariamente
  - Documentar data de remoção de compatibilidade

## Documentação de Código
- **Comentários e documentação:**
  - Funções públicas: sempre documentar com GoDoc
  - Funções complexas: explicar lógica não óbvia
  - Exemplos de uso: incluir em GoDoc quando útil
  - TODOs: incluir issue/spec número quando aplicável
- **APIs internas:**
  - Interfaces devem ter comentários explicando contrato
  - Structs complexas devem ter comentários sobre campos importantes
  - Algoritmos não triviais devem ter comentários explicativos

## Tratamento de Erros
- **Estratégia de erros:**
  - Erros devem ser tipados quando possível (criar tipos de erro específicos)
  - Mensagens de erro devem ser acionáveis e incluir contexto
  - Não usar panic exceto para erros de programação (nil pointer, etc.)
  - Erros esperados (validação, I/O) devem retornar error, não panic
- **Propagação:**
  - Adicionar contexto ao propagar erros (usar `fmt.Errorf` com `%w`)
  - Logar erros apenas na camada mais externa (commands)
  - Services não devem logar, apenas retornar erros

## Escalabilidade e Organização
- **Quando o projeto cresce:**
  - Se diretório `internal/services/` tiver > 10 serviços: considerar subdiretórios por domínio
  - Se arquivo > 500 linhas: dividir em múltiplos arquivos mantendo coesão
  - Se comando > 300 linhas: extrair lógica para serviços
- **Organização por domínio (quando necessário):**
  - Estrutura alternativa: `internal/{domain}/` (ex: `internal/specs/`, `internal/config/`)
  - Manter separação commands/services/adapters dentro de cada domínio
  - Evitar circular dependencies entre domínios

